# .github/workflows/build-and-release.yml
name: Build and Release

on:
  push:
    branches:
      - master # main åˆ†æ”¯çš„æäº¤ä¼šè§¦å‘å¼€å‘æ„å»º
    tags:
      - 'v*' # åªæœ‰ 'v' å¼€å¤´çš„æ ‡ç­¾æ‰ä¼šè§¦å‘å‘å¸ƒæ„å»º
    paths:
      - '**/requirements.txt'
      - '**/*.py'
      - '**/*.spec'
      - 'template/**'
      - 'config.json'
      - '.github/workflows/*.yml'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean

# é˜²æ­¢åŒä¸€ä¸ªå·¥ä½œæµå¯¹åŒä¸€ä¸ªæäº¤æˆ–åˆ†æ”¯çš„é‡å¤è¿è¡Œ
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: '3.11' # å»ºè®®ä½¿ç”¨ä¸»ç‰ˆæœ¬å·ï¼Œä»¥ä¾¿è·å–æœ€æ–°çš„è¡¥ä¸ç‰ˆæœ¬
  VENV_PATH: .venv # å°†è™šæ‹Ÿç¯å¢ƒç›®å½•å®šä¹‰ä¸ºå˜é‡

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # è·å–æ‰€æœ‰å†å²è®°å½•ï¼Œä»¥ä¾¿è¿›è¡Œç‰ˆæœ¬æ§åˆ¶

      - name: Set up Python and cache dependencies
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip' # setup-python ä¼šè‡ªåŠ¨å¤„ç†ç¼“å­˜é”®å’Œæ¢å¤
          cache-dependency-path: 'requirements.txt'

      - name: Get current date
        id: date
        run: echo "date=$(Get-Date -Format 'yyyy-MM-dd-HHmmss')" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Determine build type and version
        id: build_info
        shell: pwsh
        run: |
          $isRelease = $false
          $buildType = "development"
          $tagName = "dev-build-${{ steps.date.outputs.date }}"
          
          if ("${{ github.event_name }}" -eq 'workflow_dispatch') {
            $buildType = "manual"
            $tagName = "manual-build-${{ steps.date.outputs.date }}"
          } elseif ($env:GITHUB_REF -match "refs/tags/v(.+)") {
            $isRelease = $true
            $buildType = "release"
            $tagName = "v" + $matches[1]
          }
          
          echo "IS_RELEASE=$isRelease" >> $env:GITHUB_OUTPUT
          echo "BUILD_TYPE=$buildType" >> $env:GITHUB_OUTPUT
          echo "TAG_NAME=$tagName" >> $env:GITHUB_OUTPUT
          
          # è¾“å‡ºæ„å»ºä¿¡æ¯ä»¥ä¾›è°ƒè¯•
          Write-Host "=== Build Information ==="
          Write-Host "Tag Name: $tagName"
          Write-Host "Build Type: $buildType"
          Write-Host "Is Release: $isRelease"

      - name: Install or update dependencies
        run: |
          python -m venv ${{ env.VENV_PATH }}
          ${{ env.VENV_PATH }}\Scripts\python.exe -m pip install --upgrade pip
          ${{ env.VENV_PATH }}\Scripts\python.exe -m pip install -r requirements.txt

      - name: Update version number in code (for releases only)
        if: steps.build_info.outputs.IS_RELEASE == 'true'
        shell: pwsh
        run: |
          $versionFile = "gui.py"
          $tag = "${{ steps.build_info.outputs.TAG_NAME }}"
          if (Test-Path $versionFile) {
            (Get-Content $versionFile -Raw) -replace 'package_version="{version}"', "package_version=`"$tag`"" | Set-Content $versionFile
            Write-Host "âœ… Version number in $versionFile updated to $tag"
          } else {
            Write-Warning "âš ï¸ $versionFile not found, skipping version update."
          }

      - name: Clean and Build with PyInstaller
        shell: pwsh
        run: |
          Write-Host "ğŸ§¹ Cleaning previous build artifacts..."
          Remove-Item -Path "dist", "build" -Recurse -Force -ErrorAction SilentlyContinue
          
          Write-Host "ğŸ—ï¸ Building executable with PyInstaller..."
          ${{ env.VENV_PATH }}\Scripts\pyinstaller.exe auto_cuber_main.spec
          
          if (-not (Test-Path "dist\auto_cuber_main")) {
            Write-Error "âŒ PyInstaller build failed. The output directory was not found."
            exit 1
          }
          Write-Host "âœ… PyInstaller build completed successfully."

      - name: Prepare package files
        if: steps.build_info.outputs.IS_RELEASE == 'true'
        shell: pwsh
        run: |
          Write-Host "ğŸ“‹ Copying additional files to package directory..."
          $packageDir = "dist\auto_cuber_main"
          
          # å¤åˆ¶ template æ–‡ä»¶å¤¹
          if (Test-Path "template") {
            Copy-Item -Path "template" -Destination $packageDir -Recurse
            Write-Host "âœ… Copied 'template' folder."
          } else {
            Write-Warning "âš ï¸ 'template' folder not found."
          }
          
          # å¤åˆ¶å…¶ä»–æ–‡ä»¶
          $filesToCopy = @("config.json", "ä½¿ç”¨è¯´æ˜.pdf", "æ›´æ–°å†…å®¹.txt")
          foreach ($file in $filesToCopy) {
            if (Test-Path $file) {
              Copy-Item -Path $file -Destination $packageDir
              Write-Host "âœ… Copied '$file'."
            } else {
              Write-Warning "âš ï¸ '$file' not found."
            }
          }

      - name: Create ZIP archive
        if: steps.build_info.outputs.IS_RELEASE == 'true'
        id: package
        shell: pwsh
        run: |
          $packageDir = "dist\auto_cuber_main"
          $zipFileName = "auto_cuber_main_${{ steps.build_info.outputs.TAG_NAME }}.zip"
          $zipFilePath = "dist\$zipFileName"
          
          Compress-Archive -Path $packageDir\* -DestinationPath $zipFilePath -Force
          
          if (-not (Test-Path $zipFilePath)) {
              Write-Error "âŒ Failed to create ZIP archive."
              exit 1
          }
          
          $zipInfo = Get-Item $zipFilePath
          Write-Host "âœ… ZIP package created: $zipFileName"
          Write-Host "Size: $([math]::Round($zipInfo.Length / 1MB, 2)) MB"
          
          echo "zip_path=$zipFilePath" >> $env:GITHUB_OUTPUT
          echo "zip_name=$zipFileName" >> $env:GITHUB_OUTPUT

      - name: Extract Changelog for Release
        id: changelog
        if: steps.build_info.outputs.IS_RELEASE == 'true'
        shell: pwsh
        run: |
          $changelogFile = "æ›´æ–°å†…å®¹.txt"
          $changelogText = "æš‚æ— æ›´æ–°å†…å®¹ã€‚" # é»˜è®¤å€¼
          if (Test-Path $changelogFile) {
              $content = Get-Content $changelogFile -Raw -Encoding UTF8
              $currentTag = "${{ steps.build_info.outputs.TAG_NAME }}" -replace "^v", ""
          
              # ä½¿ç”¨æ›´å¥å£®çš„æ­£åˆ™è¡¨è¾¾å¼æ¥åŒ¹é…ç‰ˆæœ¬å—
              $pattern = "(?msi)^v?$currentTag`s*:`r?`n(.+?)(?=`r?`n^v?\d|`$)"
              if ($content -match $pattern) {
                  $changelogText = $matches[1].Trim()
              } else {
                  $changelogText = "æ— æ³•è‡ªåŠ¨æå–å½“å‰ç‰ˆæœ¬çš„æ›´æ–°æ—¥å¿—ï¼Œä»¥ä¸‹æ˜¯å®Œæ•´å†…å®¹ï¼š`n`n" + $content
              }
          }
          
          # å°†å¤šè¡Œå­—ç¬¦ä¸²ä¼ é€’ç»™ GITHUB_OUTPUT
          $delimiter = "EOF"
          echo "CHANGELOG<<$delimiter" >> $env:GITHUB_OUTPUT
          echo "$changelogText" >> $env:GITHUB_OUTPUT
          echo "$delimiter" >> $env:GITHUB_OUTPUT
          Write-Host "âœ… Changelog extracted."



      - name: Create GitHub Release
        if: steps.build_info.outputs.IS_RELEASE == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.build_info.outputs.TAG_NAME }}
          name: Release ${{ steps.build_info.outputs.TAG_NAME }}
          body: |            
            ${{ steps.changelog.outputs.CHANGELOG }}
            
            ---
            
            **æ„å»ºä¿¡æ¯:**
            - **æ„å»ºæ—¶é—´:** ${{ steps.date.outputs.date }}
            - **æäº¤ SHA:** `${{ github.sha }}`
            - **Python ç‰ˆæœ¬:** `${{ env.PYTHON_VERSION }}`

          files: |
            dist/${{ steps.package.outputs.zip_name }}
          draft: false
          prerelease: false